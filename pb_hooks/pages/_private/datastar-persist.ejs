<script type="module">
  import {
    load,
    apply
  } from 'https://cdn.jsdelivr.net/gh/starfederation/datastar@main/bundles/datastar.js'

  // Dynamic delay per call - needed for handlers with configurable throttling
  export function createDynamicThrottle() {
    let timeoutId = null;
    let lastExecTime = 0;

    return (func, delay = 150) => {
      const currentTime = Date.now();
      const timeSinceLastExec = currentTime - lastExecTime;

      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      if (timeSinceLastExec >= delay) {
        func();
        lastExecTime = currentTime;
      } else {
        const remainingDelay = delay - timeSinceLastExec;
        timeoutId = setTimeout(() => {
          func();
          lastExecTime = Date.now();
          timeoutId = null;
        }, remainingDelay);
      }
    };
  }

  // RAF throttling syncs with display refresh rate for smooth animations
  export function createRAFThrottle(func) {
    let rafId = null;

    return function(...args) {
      if (rafId !== null) return;

      rafId = requestAnimationFrame(() => {
        try {
          func.apply(this, args);
        } finally {
          // Prevent memory leak if func throws
          rafId = null;
        }
      });
    };
  }

  // Timer-based throttling for configurable delays
  export function createTimerThrottle(func, delay) {
    let timeoutId;
    let lastExecTime = 0;

    return function(...args) {
      const currentTime = Date.now();

      if (currentTime - lastExecTime > delay) {
        func.apply(this, args);
        lastExecTime = currentTime;
      } else {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
          lastExecTime = Date.now();
        }, delay - (currentTime - lastExecTime));
      }
    };
  }

  // WeakMap ensures throttle state is garbage collected with elements
  export function createElementThrottle() {
    const throttleConfigs = new WeakMap();

    return (element, func, delay = 150) => {
      let config = throttleConfigs.get(element);
      if (!config) {
        config = {
          lastExec: 0,
          timeoutId: null
        };
        throttleConfigs.set(element, config);
      }

      const now = Date.now();
      const timeSinceLastExec = now - config.lastExec;

      if (config.timeoutId) {
        clearTimeout(config.timeoutId);
        config.timeoutId = null;
      }

      if (timeSinceLastExec >= delay) {
        config.lastExec = now;
        return func.call(element);
      }
      const remainingDelay = delay - timeSinceLastExec;
      config.timeoutId = setTimeout(() => {
        config.lastExec = Date.now();
        config.timeoutId = null;
        func.call(element);
      }, remainingDelay);
    };
  }

  // Debouncing waits for events to stop - useful for search input, resize events
  export function createDebounce(func, delay) {
    let timeoutId = null;

    return function(...args) {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      timeoutId = setTimeout(() => {
        func.apply(this, args);
        timeoutId = null;
      }, delay);
    };
  }


  function mergePatch(patch) {
    const mp = window.__datastar_mergePatch;
    if (mp) {
      mp(patch);
    } else {
      console.error('Datastar mergePatch not available');
    }
  }

  function getPath(path) {
    const gp = window.__datastar_getPath;
    if (gp) {
      return gp(path);
    }
    console.error('Datastar getPath not available');
    return undefined;
  }

  function effect(fn) {
    const eff = window.__datastar_effect;
    if (eff) {
      return eff(fn);
    }
    console.error('Datastar effect not available');
    return () => {};
  }

  const DEFAULT_STORAGE_KEY = "starhtml-persist";
  const DEFAULT_THROTTLE = 500;

  function getStorage(isSession) {
    try {
      const storage = isSession ? sessionStorage : localStorage;
      storage.setItem("__test__", "1");
      storage.removeItem("__test__");
      return storage;
    } catch {
      return null;
    }
  }

  function getModValue(mods, key) {
    const val = mods.get(key);
    return val instanceof Set ? Array.from(val)[0] : val;
  }

  function parseSignals(value) {
    return value
      .split(/[,;]/)
      .map(s => s.trim())
      .map(s => (s.startsWith("$") ? s.slice(1) : s))
      .filter(Boolean);
  }

  function loadFromStorage(storage, key, signals) {
    try {
      const stored = storage.getItem(key);
      if (!stored) return;

      const data = JSON.parse(stored);
      if (!data || typeof data !== "object") return;

      if (signals.length === 0) return;

      const patch = Object.fromEntries(
        signals
        .filter(signal => signal in data)
        .map(signal => [signal, data[signal]])
      );
      if (Object.keys(patch).length > 0) {
        mergePatch(patch);
      }
    } catch {}
  }

  function saveToStorage(storage, key, data) {
    if (Object.keys(data).length === 0) return;

    try {
      const stored = storage.getItem(key);
      const existing = stored ? JSON.parse(stored) : {};
      storage.setItem(key, JSON.stringify({
        ...existing,
        ...data
      }));
    } catch {}
  }

  const persistAttributePlugin = {
    name: "persist",
    type: "attribute",
    keyReq: "allowed",
    valReq: "allowed",
    shouldEvaluate: false,

    onLoad(ctx) {
      const {
        key,
        value,
        mods
      } = ctx;
      const storage = getStorage(mods.has("session"));
      if (!storage) return;

      const customKey = key || getModValue(mods, "key");
      const storageKey = customKey ?
        `${DEFAULT_STORAGE_KEY}-${String(customKey)}` :
        DEFAULT_STORAGE_KEY;

      const trimmed = value?.trim();
      const signals = trimmed ? parseSignals(trimmed) : [];

      if (signals.length > 0) {
        loadFromStorage(storage, storageKey, signals);
      }

      const throttleMs = mods.has("immediate") ?
        0 :
        Number.parseInt(String(getModValue(mods, "throttle") ?? DEFAULT_THROTTLE));

      let cachedData = {};
      let lastSavedData = null;

      const isShallowEqual = (a, b) => {
        if (!a) return false;
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) return false;
        for (const k of aKeys) {
          if (a[k] !== b[k]) return false;
        }
        return true;
      };

      const persist = () => {
        if (Object.keys(cachedData).length === 0) return;
        if (isShallowEqual(lastSavedData, cachedData)) return;
        saveToStorage(storage, storageKey, cachedData);
        lastSavedData = {
          ...cachedData
        };
      };

      const throttledPersist = throttleMs > 0 ? createDebounce(persist, throttleMs) : persist;

      if (signals.length === 0) return;

      return effect(() => {
        const data = {};
        for (const signal of signals) {
          try {
            data[signal] = getPath(signal);
          } catch {}
        }
        cachedData = data;
        throttledPersist();
      });
    },
  };




  load(persistAttributePlugin)
  apply()
</script>